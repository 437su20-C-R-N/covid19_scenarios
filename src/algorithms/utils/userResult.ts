import { UserResult, ExportedTimePoint } from '../types/Result.types'
import { ProcessingError, ProcessingErrorCode } from './exceptions'
import { EmpiricalData } from '../types/Param.types'

// These are the columns we got from currently exported files.
// They my not be present in the user results.
enum RawUserResultColumn {
  Time = 'time',
  Susceptible = 'susceptible',
  Severe = 'severe',
  Exposed =  'exposed',
  Overflow = 'overflow',
  ICU = 'ICU',
  Infectious = 'infectious',
  CumulativeRecovered = 'cumulative_recovered',
  CumulativeHospitalized = 'cumulative_hospitalized',
  CumulativeCritical = 'cumulative_critical',
  CumulativeFatality = 'cumulative_fatality',
}

function formatData(rawData: string): Record<string, number> | undefined {
  const parsed = rawData ? { total: +rawData } : undefined

  if (parsed && isNaN(parsed.total)) {
    throw new ProcessingError(ProcessingErrorCode.InvalidField, rawData)
  }

  return parsed
}

/**
 * Build a {UserResult} from the raw file data.
 * @param rawUserResult Result of the parsed CSV file, containing an array of objects representing each row, with headers as keys.
 *    This is typically the format generated by Papa.parse with option 'headers' enabled.
 */
export function processUserResult(rawUserResult: Record<RawUserResultColumn, string>[]): UserResult {
  const trajectory: ExportedTimePoint[] = []

  for (const row of rawUserResult) {
    if (!row.time) {
      throw new ProcessingError(ProcessingErrorCode.MissingTimeField)
    }

    const rowTime = +new Date(row.time)

    if (!rowTime) {
      throw new ProcessingError(ProcessingErrorCode.InvalidField, row.time)
    }

    trajectory.push({
      time: rowTime,
      cumulative: {
        critical: formatData(row.cumulative_critical),
        fatality: formatData(row.cumulative_fatality),
        hospitalized: formatData(row.cumulative_hospitalized),
        recovered: formatData(row.cumulative_recovered),
      },
      current: {
        exposed: formatData(row.exposed),
        infectious: formatData(row.infectious),
        overflow: formatData(row.overflow),
        severe: formatData(row.severe),
        susceptible: formatData(row.susceptible),
        critical: formatData(row.ICU),
      },
    })
  }

  return { trajectory }
}

/**
 * Convert the custom case count imported as a {UserResult} object to a {EmpiricalData} object as used in the model.
 * @param userResult The userResult object holding the imported data.
 */
export function convertUserResultToEmpiricalData(userResult: UserResult): EmpiricalData {
  return userResult.trajectory.map((dataPoint: ExportedTimePoint) => ({
    time: new Date(dataPoint.time),
    cases: dataPoint.current.infectious?.total || null,
    deaths: dataPoint.cumulative.fatality?.total || null,
    hospitalized: dataPoint.current.severe?.total || null,
    icu: dataPoint.current.critical?.total || null,
    recovered: dataPoint.cumulative.recovered?.total || null,
  }))
}
